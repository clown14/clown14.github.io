---
title: Core Java I 学习笔记(四)
date: 2017-04-02 16:31:37
tags: Java
categories: Java
---

继承
<!-- more -->

利用继承，可以基于已存在的类构造一个新类。继承已存在的类就是复用这些类的方法和域。在此基础上，还可以添加一些新的的方法和域，以满足新的需求。

## 类、超类和子类

### 定义子类

关键字***extends***表明正在构造的新类派生于一个已存在的类。已存在的类称为超类（superclass）、基类（base class）或父类（parent class）；新类称为之类（subclass）、派生类（derived class）或孩子类（child class）。
子类往往比超类拥有的功能更加丰富。

	public class Manager extends Employee //继承Employee类来定义Manager类
	{
		添加方法和域
	}

### 覆盖方法

如果子类，超类中存在同名方法，子类中默认调用本身存在的方法，称为**覆盖**。
如果需要调用超类中的同名方法，可以使用***super***关键字：

	super.方法

**注**：super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。与this不同，this有两个用途，一是引用隐式参数，二是调用该类其他的构造器。super也有两个用途，一是调用超类方法，二是调用超类构造器。

### 多态

一个对象变量可以指示多种实际类型的现象被称为**多态（polymorphism）**，在运行时能够自动地调用哪个方法的现象称为**动态绑定（dynamic binding）**。

	Employee e;
	e= new Employee(..);
	e= new Manager(..);

Java中，对象变量是多态的。一个Employee变量既可以引用一个Employee类对象，也可以引用一个Employee类的任何一个子类的对象。（不能将超类的引用赋给之类变量）

### 理解方法调用

假设调用x.f(args)，隐式参数x声明为类C的一个对象。

1. 编译器查看对象的声明类型和方法名。至此，编译器获得所有可能被调用的方法。
2. 编译器查看调用方法时提供的参数类型，也称**重载解析（overloading resolution）**。至此，编译器获取需要调用的方法名字和参数类型。
3. 如果是private、static、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，也称**静态绑定（static binding）**。与此对应的是，调用的方法依赖于隐式参数的实际类型，并在运行时实现动态绑定。
4. 但程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。

### 阻止继承：final类和方法

不允许扩展的类被称为final类。使用final修饰符声明。类的特定方法也可以被声明为final。如果这样，子类就不能覆盖整个方法。final类中所有方法自动变成final方法。

### 抽象类

如果自下而上在类的继承层次结构中上移，位于上层的类更具有通用性，甚至可能更加抽象。从某种角度看，祖先类更加通用，人们只将它作为派生其他类的基类，而不作为想使用的特定的实例类。

包含一个或多个抽象方法的类本身必须被声明为抽象的。抽象方法不必实现。抽象类不能被实例化。

抽象方法充当着占位的角色，它们的具体实现在子类中。拓展实体类可以有两种选择。一种是在抽象类中定义抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类；另一种是定义全部的抽象方法，这样一来，之类就不是抽象的了。

## Object：所有类的超类

Object类是Java中所有类的始祖，每个类都是由它拓展而来。

### equals方法

判断两个对象是否具有相同的引用。

### hashCode方法

**散列码（hash code）**是由对象导出的一个整数值。散列码没有规律。每个对象都有一个默认的散列码，其值为对象的存储地址。

### toString方法

Object中，toString方法用于返回表示对象值的字符串。

## 对象包装器

所有的基本类型都有一个与之对应的类。也称**包装器**。分别是Integer、Long、Float、Double、Short、Byte、Character、Void、Doolean。对象包装器是不可变的，一旦构造了包装器，就不允许更改包装在其中的值。

## 枚举类

枚举类型包括有限个命名的值，如：

	public enum Size{SMALL,MEDIUM,LARGE,EXTRA_LARGE};

实际上，这个声明定义的类型是一个类，它刚好有4个实例，在此尽量不要构造新对象。

## 反射

能够分析类能力的程序称为**反射（reflective）**。反射机制可以用来：

* 在运行时分析类的能力。
* 在运行时查看对象，例如，编写一个toString方法供所有类使用。
* 实现通用的数组操作代码。
* 利用Method对象，这个对象很像C++中的函数指针。

在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运动时的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。Java中用Class类保存这些信息。

反射机制最重要的内容是检查类的结构。
查看任意对象的数据域名称和类型：
* 获得对应的Class对象。
* 通过Class对象调用getDeclaredFields。

## 继承设计技巧

1. 将公共操作和域放在超类
2. 不要使用受保护的域
3. 使用继承实现“is-a”关系
4. 除非所有继承的方法都有意义，否则不要使用继承
5. 在覆盖方法时，不要改变预期的行为
6. 使用多态，而非类型信息
7. 不要过多地使用反射